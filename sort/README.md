# ソートアルゴリズムまとめ

## バブルソート

- 隣り合う要素の大小を比較しながら整列させる。
- アルゴリズムが単純で実装が用意なため、並列処理との親和性が高い。
- バブルソートを 1 回行うと最後の要素が最大になるため、次回のスキャン範囲を 1 狭めることができる。
- そのため、最悪計算時間は、n-1+n-2...1=n(n-1)/2 である。
- よって計算量は O(n^2)
- 最後に要素の交換を行った位置から、スキャン範囲の最後の要素にたどり着くまでの間に連続して要素の交換が発生しない場合にはスキャン回数を大幅に狭めることができる。--> つまり、ソート済みの部分があると実行速度が上がる。

---

## 挿入ソート

- ある程度整列済みのデータに関して実行すると速い。
- すべての値を順に調べ，各値をあるべき位置に挿入するソート方法。
- 最悪計算量は 1 + 2... n-1=(n)(n-1)/2
- よって計算量は O(n^2)

## 選択ソート

- 未整列のデータから最小値を探し、それを左端に置いて、次の最小値検索範囲を 1 つ小さくするという操作を繰り返す。
- 最小値を求める方法は検索範囲の左端を最小値と仮定し、検索範囲の要素を一つずつ確認して、仮定した最小値より小さいものがあれば入れ替えるという操作を繰り返して求める。
- リストサイズを n とすると、1 回目は n 回の探索、2 回目は n-1 回の探索が必要になる。そのため、ステップ数は n + (n-1) + (n -2) ... = n(n+1)/2 　となる。
- よって計算量は O(n\*\*2)となる。

---

## マージゾート

- 2 つのソート済みの配列をつなげてソートする方法。配列を 1 個ずつに分解して，マージする過程で順番を並べることを繰り返す。
- 問題を細かく分割し、簡単な問題を解くことを積み重ねて全体の回を得るマージソートのような問題を分割統治法(divide-and-conquer method)と呼ぶ。
- スターリングの近似により最善のアルゴリズムであることが知られる。

---

## クイックソート

- 分割統治法(divide-and-conquer method)の一つ。
- 配列から pivot を選択し、pivot より小さいか大きいかで配列を 2 つに分割する操作を繰り返すことで最終的に配列が完全に分割されてソートされた状態になる。
- マージソートと計算量は同じだが、pivot を一定の場所から集めると、一部がソートされている配列に対しては pivot で要素が減らしにくいのでパフォーマンスが悪くなる。
- そこで pivot は欄抱くに選択するようになっており、このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。

---

./insert_sort.py

## シェルソート

- 挿入ソートの改良版。
- クイックソートが発見されるまでは最も高速なソートアルゴリズムだった。
- 挿入ソートがある程度整列済みのデータに関して高速であることを利用して予め整列度を高めるための前処理を行う。
- h-ソート: 前処理として一定の距離(h)離れた要素を比較し，ソートする。
- h を 3n+1 としてループを回す毎に h を 3 で割る(切り捨て)しつつ，挿入ソートと同様に 2 つの値を比較して並べることを繰り返す。

---

## quick ソート

- pivot と呼ばれる基準を適当に選び、pivot より小さいなら左、大きいなら右に要素を移動する。これを繰り返す。
- 計算量は O(nlog n)で mergesort と同じ。

- クイックソートの大きな弱点として配列がすでにソートされているとパフォーマンスが悪くなるというものがある。なぜなら、本コードでは pivot の位置を一番最後にしているのでソート済みだと pivot の左は n-1 個にしかならないため、(n-1) + (n-2)... 1 = (n-1)(n-2)/2 となり計算量は O(n\*\*2)になる。
- そこで、pivot をランダムに選択するように改良する。このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。

## ヒープソート

- 木構造の一種であるヒープというデータ構造を用いて，データを並び替えるソート方法。
- ヒープとは: 木のデータ構造のうち，どの親子も親>=子，あるいは親<=子の関係にあること。

---
