# ソートアルゴリズムまとめ
## バブルソート
- 隣り合う要素の大小を比較しながら整列させる。
- アルゴリズムが単純で実装が用意なため、並列処理との親和性が高い。
- バブルソートを1回行うと最後の要素が最大になるため、次回のスキャン範囲を1狭めることができる。
- そのため、最悪計算時間は、n-1+n-2...1=n(n-1)/2である。
- 最後に要素の交換を行った位置から、スキャン範囲の最後の要素にたどり着くまでの間に連続して要素の交換が発生しない場合にはスキャン回数を大幅に狭めることができる。つまり、ソート済みの部分があると実行速度が上がる。
- 計算量はO(n^2)
******


## 選択ソート
- 未整列のデータから最小値を探し、それを左端に置いて、次の最小値検索範囲を1つ小さくするという操作を繰り返す。
- 最小値を求める方法は検索範囲の左端を最小値と仮定し、検索範囲の要素を一つずつ確認して、仮定した最小値より小さいものがあれば入れ替えるという操作を繰り返して求める。
- 最悪時間計算量がO(n^2)と大きいため，一般的には使われないが，配列が小さい場合には使われることもある。
******


## マージゾート
- 2つのソート済みの配列をつなげてソートする方法。配列を1個ずつに分解して，マージする過程で順番を並べることを繰り返す。
- 問題を細かく分割し、簡単な問題を解くことを積み重ねて全体の回を得るマージソートのような問題を分割統治法(divide-and-conquer method)と呼ぶ。
- スターリングの近似により最善のアルゴリズムであることが知られる。
******

## クイックソート
- 分割統治法(divide-and-conquer method)の一つ。
- 配列からpivotを選択し、pivotより小さいか大きいかで配列を2つに分割する操作を繰り返すことで最終的に配列が完全に分割されてソートされた状態になる。
- マージソートと計算量は同じだが、pivotを一定の場所から集めると、一部がソートされている配列に対してはpivotで要素が減らしにくいのでパフォーマンスが悪くなる。
- そこでpivotは欄抱くに選択するようになっており、このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。
******


## 挿入ソート
- ある程度整列済みのデータに関して実行すると速い。
- すべての値を順に調べ，各値をあるべき位置に挿入するソート方法。
- まず，左端(i=0)と1つ右隣(i=1)を比較して小さい方を左にする。
- 次に，さらに1つ右(i=2)をi=1，i=0と比較してi=2より小さい値が出てくる一つ手前に配置する。これを繰り返す。
./insert_sort.py


## シェルソート
- 挿入ソートの改良版。
- クイックソートが発見されるまでは最も高速なソートアルゴリズムだった。
- 挿入ソートがある程度整列済みのデータに関して高速であることを利用して予め整列度を高めるための前処理を行う。
- h-ソート: 前処理として一定の距離(h)離れた要素を比較し，ソートする。
- hを3n+1としてループを回す毎にhを3で割る(切り捨て)しつつ，挿入ソートと同様に2つの値を比較して並べることを繰り返す。

******


## quickソート
- pivotと呼ばれる基準を適当に選び、pivotより小さいなら左、大きいなら右に要素を移動する。これを繰り返す。
- 計算量はO(nlog n)でmergesortと同じ。

- クイックソートの大きな弱点として配列がすでにソートされているとパフォーマンスが悪くなるというものがある。なぜなら、本コードではpivotの位置を一番最後にしているのでソート済みだとpivotの左はn-1個にしかならないため、(n-1) + (n-2)... 1 = (n-1)(n-2)/2となり計算量はO(n\*\*2)になる。
-  そこで、pivotをランダムに選択するように改良する。このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。


## ヒープソート
- 木構造の一種であるヒープというデータ構造を用いて，データを並び替えるソート方法。
- ヒープとは: 木のデータ構造のうち，どの親子も親>=子，あるいは親<=子の関係にあること。
******
