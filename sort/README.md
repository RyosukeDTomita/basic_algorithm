# ソートアルゴリズムまとめ

## バブルソート

- 隣り合う要素の大小を比較しながら整列させる。
- アルゴリズムが単純で実装が用意なため、並列処理との親和性が高い。
- バブルソートを 1 回行うと最後の要素が最大になるため、次回のスキャン範囲を 1 狭めることができる。
- そのため、平均計算時間は、n-1+n-2...1=n(n-1)/2 である。
- よって計算量は O(n^2)
- 最後に要素の交換を行った位置から、スキャン範囲の最後の要素にたどり着くまでの間に連続して要素の交換が発生しない場合にはスキャン回数を大幅に狭めることができる。--> つまり、ソート済みの部分があると実行速度が上がる。

---

## 挿入ソート

- ある程度整列済みのデータに関して実行すると速い。
- すべての値を順に調べ，各値をあるべき位置に挿入するソート方法。
- 平均計算量は配列の i 番目の要素に対して右隣と比較を行うので 1 + 2 + 3 ... n-1 = (n-1)(n)/2
- よって計算量は O(n^2)

## 選択ソート

- 未整列のデータから最小値を探し、それを左端に置いて、次の最小値検索範囲を 1 つ小さくするという操作を繰り返す。
- 最小値を求める方法は検索範囲の左端を最小値と仮定し、検索範囲の要素を一つずつ確認して、仮定した最小値より小さいものがあれば入れ替えるという操作を繰り返して求める。
- リストサイズを n とすると、1 回目は n 回の探索、2 回目は n-1 回の探索が必要になる。そのため、ステップ数は n + (n-1) + (n -2) ... 1 = n(n+1)/2 　となる。
- よって計算量は O(n^2)となる。

---

## マージゾート

- 2 つのソート済みの配列をつなげてソートする方法。配列を 1 個ずつに分解して，マージする過程で順番を並べることを繰り返す。
- そのため，まず配列をサイズ 1 まで小さくしてそれを結合する過程でマージする操作を繰り返す。
- 問題を細かく分割し、簡単な問題を解くことを積み重ねて全体の回を得るマージソートのような問題を分割統治法(divide-and-conquer method)と呼ぶ。

### マージソートの計算量

- 配列の要素数を n とする。ただし，n>=2 とする。
- 再帰的に呼び出されるマージソートは，左右対象な 2 分木を使って表現できる。この木の高さは log2 n である。

```
# 2分木の高さlog2 8 = 4の例
[1] [2] [3] [4] [5] [6] [7] [8] # 1段目
[1, 2] [3, 4] [5, 6] [7, 8]  # 2段目 (上の段を4回マージ)
[1, 2, 3, 4] [5, 6, 7, 8]  # 3段目 (上の段を2回マージ)
[1, 2, 3, 4, 5, 6, 7, 8]  # 4段目 (上の段を1回マージ)
```

- この木の高さ log2 n に対して、2 分木の高さを半分にするには，おおよそ n/2 回のマージが必用である。
- このことからマージソートの計算量は O(nlog2 n) であることがわかる。

### スターリングの近似

> [スターリングの近似](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E8%BF%91%E4%BC%BC)

- 要素数 n 個の配列をソートできるということは，n! 通りの順列をソートできるということである。
- 配列の個数は木の高さを k とするとおおよそ 2^k である。
- ソートアルゴリズムは n!通りの配列をソートできる必用があるので，2^k >= n!である必用がある。
- ここでスターリングの近似により，n! 〜 (n/e)^n \* √(2πn) である。
- つまり，2^k >= (n/e)^n \* √(2πn) である。
- これを変形して，k >= nlog2 n - nlog2 e + 1/2log2(2πn) であるためマージソートの計算量は理論上最小であることがわかる。

---

## クイックソート

- マージソートと同じ分割統治法(divide-and-conquer method)に分類される。
- 配列から pivot を選択し、pivot より小さいか大きいかで配列を 2 つに分割し，分割した配列それぞれに対してこの操作を繰り返していくことでソートされる。
-
- 計算量は O(nlog2 n)
  > [!NOTE]
  > クイックソートは高速だが，ピボットの位置を固定している場合にパフォーマンスが落ちてしまうことがある。これは，ピボットで配列を 2 つに分割した時に片方に配列のサイズが大きくなってしまった場合にパフォーマンスが悪くなる。
  > つまり，ソート済みの配列に対しては毎回分割が発生するため，1 + 2 + 3 ... n-1 = (n)(n-1)/2 となるため最悪計算量は O(n^2)である。
- そこで pivot をランダムに選択するようにすることで、パフォーマンスが劇的に低下することを防ぐことができる。
- このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。

---

## シェルソート

- 挿入ソートの改良版。
- クイックソートが発見されるまでは最も高速なソートアルゴリズムだった。
- 挿入ソートがある程度整列済みのデータに関して高速であることを利用して予め整列度を高めるための前処理を行う。
- h-ソート: 前処理として一定の距離(h)離れた要素を比較し，ソートする。
- h を 3n+1 としてループを回す毎に h を 3 で割る(切り捨て)しつつ，挿入ソートと同様に 2 つの値を比較して並べることを繰り返す。

---

## quick ソート

- pivot と呼ばれる基準を適当に選び、pivot より小さいなら左、大きいなら右に要素を移動する。これを繰り返す。
- 計算量は O(nlog n)で mergesort と同じ。

- クイックソートの大きな弱点として配列がすでにソートされているとパフォーマンスが悪くなるというものがある。なぜなら、本コードでは pivot の位置を一番最後にしているのでソート済みだと pivot の左は n-1 個にしかならないため、(n-1) + (n-2)... 1 = (n-1)(n-2)/2 となり計算量は O(n\*\*2)になる。
- そこで、pivot をランダムに選択するように改良する。このようにアルゴリズムの実行にランダムな要素を含むものを乱択アルゴリズムという。

## ヒープソート

- 木構造の一種であるヒープというデータ構造を用いて，データを並び替えるソート方法。
- ヒープとは: 木のデータ構造のうち，どの親子も親>=子，あるいは親<=子の関係にあること。

---
